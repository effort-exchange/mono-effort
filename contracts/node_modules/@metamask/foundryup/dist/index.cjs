#!/usr/bin/env -S node --require "./node_modules/tsx/dist/preflight.cjs" --import "./node_modules/tsx/dist/loader.mjs"
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.downloadAndInstallFoundryBinaries = exports.installBinaries = exports.checkAndDownloadBinaries = exports.getBinaryArchiveUrl = exports.getCacheDirectory = void 0;
const node_crypto_1 = require("node:crypto");
const node_fs_1 = require("node:fs");
const promises_1 = require("node:fs/promises");
const node_os_1 = require("node:os");
const node_path_1 = require("node:path");
const node_process_1 = require("node:process");
const yaml_1 = require("yaml");
const extract_1 = require("./extract.cjs");
const options_1 = require("./options.cjs");
const types_1 = require("./types.cjs");
const utils_1 = require("./utils.cjs");
/**
 * Determines the cache directory based on the .yarnrc.yml configuration.
 * If global cache is enabled, returns a path in the user's home directory.
 * Otherwise, returns a local cache path in the current working directory.
 *
 * @returns The path to the cache directory
 */
function getCacheDirectory() {
    let enableGlobalCache = false;
    try {
        const configFileContent = (0, node_fs_1.readFileSync)('.yarnrc.yml', 'utf8');
        const parsedConfig = (0, yaml_1.parse)(configFileContent);
        enableGlobalCache = parsedConfig?.enableGlobalCache ?? false;
    }
    catch (error) {
        // If file doesn't exist or can't be read, default to local cache
        if (error.code === 'ENOENT') {
            return (0, node_path_1.join)((0, node_process_1.cwd)(), '.metamask', 'cache');
        }
        // For other errors, log but continue with default
        console.warn('Warning: Error reading .yarnrc.yml, using local cache:', error);
    }
    return enableGlobalCache
        ? (0, node_path_1.join)((0, node_os_1.homedir)(), '.cache', 'metamask')
        : (0, node_path_1.join)((0, node_process_1.cwd)(), '.metamask', 'cache');
}
exports.getCacheDirectory = getCacheDirectory;
/**
 * Generates the URL for downloading the Foundry binary archive.
 *
 * @param repo - The GitHub repository (e.g., 'foundry-rs/foundry')
 * @param tag - The release tag (e.g., 'v1.0.0')
 * @param version - The version string
 * @param platform - The target platform (e.g., Platform.Linux)
 * @param arch - The target architecture (e.g., 'amd64')
 * @returns The URL for the binary archive
 */
function getBinaryArchiveUrl(repo, tag, version, platform, arch) {
    const ext = platform === types_1.Platform.Windows ? types_1.Extension.Zip : types_1.Extension.Tar;
    return `https://github.com/${repo}/releases/download/${tag}/foundry_${version}_${platform}_${arch}.${ext}`;
}
exports.getBinaryArchiveUrl = getBinaryArchiveUrl;
/**
 * Checks if binaries are already in the cache. If not, downloads and extracts them.
 *
 * @param url - The URL to download the binaries from
 * @param binaries - The list of binaries to download
 * @param cachePath - The path to the cache directory
 * @param platform - The target platform
 * @param arch - The target architecture
 * @param checksums - Optional checksums for verification
 * @returns A promise that resolves to the directory containing the downloaded binaries
 */
async function checkAndDownloadBinaries(url, binaries, cachePath, platform, arch, checksums) {
    let downloadedBinaries;
    try {
        (0, utils_1.say)(`checking cache`);
        downloadedBinaries = await (0, promises_1.opendir)(cachePath);
        (0, utils_1.say)(`found binaries in cache`);
    }
    catch (e) {
        (0, utils_1.say)(`binaries not in cache`);
        if (e.code === 'ENOENT') {
            (0, utils_1.say)(`installing from ${url.toString()}`);
            // directory doesn't exist, download and extract
            const platformChecksums = (0, utils_1.transformChecksums)(checksums, platform, arch);
            await (0, extract_1.extractFrom)(url, binaries, cachePath, platformChecksums);
            downloadedBinaries = await (0, promises_1.opendir)(cachePath);
        }
        else {
            throw e;
        }
    }
    return downloadedBinaries;
}
exports.checkAndDownloadBinaries = checkAndDownloadBinaries;
/**
 * Installs the downloaded binaries by creating symlinks or copying files.
 *
 * @param downloadedBinaries - The directory containing the downloaded binaries
 * @param BIN_DIR - The target directory for installation
 * @param cachePath - The path to the cache directory
 * @returns A promise that resolves when installation is complete
 */
async function installBinaries(downloadedBinaries, BIN_DIR, cachePath) {
    for await (const file of downloadedBinaries) {
        if (!file.isFile()) {
            continue;
        }
        const target = (0, node_path_1.join)(file.parentPath, file.name);
        const path = (0, node_path_1.join)(BIN_DIR, (0, node_path_1.relative)(cachePath, target));
        // compute the relative path from where the symlink will be created
        // to the target file, so that it works even if the project is moved
        // (like in some CI environments)
        const relativeTarget = (0, node_path_1.relative)((0, node_path_1.dirname)(path), target);
        // create the BIN_DIR paths if they don't exists already
        await (0, promises_1.mkdir)(BIN_DIR, { recursive: true });
        // clean up any existing files or symlinks
        await (0, promises_1.unlink)(path).catch(utils_1.noop);
        try {
            // create new symlink
            await (0, promises_1.symlink)(relativeTarget, path);
        }
        catch (e) {
            if (!((0, utils_1.isCodedError)(e) && ['EPERM', 'EXDEV'].includes(e.code))) {
                throw e;
            }
            // symlinking can fail if it's a cross-device/filesystem link, or for
            // permissions reasons, so we'll just copy the file instead
            await (0, promises_1.copyFile)(target, path);
        }
        // check that it works by logging the version
        (0, utils_1.say)(`installed - ${(0, utils_1.getVersion)(path).toString()}`);
    }
}
exports.installBinaries = installBinaries;
/**
 * Downloads and installs Foundry binaries based on command-line arguments.
 * If the command is 'cache clean', it removes the cache directory.
 * Otherwise, it downloads and installs the specified binaries.
 *
 * @returns A promise that resolves when the operation is complete
 */
async function downloadAndInstallFoundryBinaries() {
    const parsedArgs = (0, options_1.parseArgs)();
    const CACHE_DIR = getCacheDirectory();
    if (parsedArgs.command === 'cache clean') {
        await (0, promises_1.rm)(CACHE_DIR, { recursive: true, force: true });
        (0, utils_1.say)('done!');
        (0, node_process_1.exit)(0);
    }
    const { repo, version: { version, tag }, arch, platform, binaries, checksums, } = parsedArgs.options;
    (0, options_1.printBanner)();
    const bins = binaries.join(', ');
    (0, utils_1.say)(`fetching ${bins} ${version} for ${platform} ${arch}`);
    const BIN_ARCHIVE_URL = getBinaryArchiveUrl(repo, tag, version, platform, arch);
    const BIN_DIR = (0, node_path_1.join)((0, node_process_1.cwd)(), 'node_modules', '.bin');
    const url = new URL(BIN_ARCHIVE_URL);
    const cacheKey = (0, node_crypto_1.createHash)('sha256')
        .update(`${BIN_ARCHIVE_URL}-${bins}`)
        .digest('hex');
    const cachePath = (0, node_path_1.join)(CACHE_DIR, cacheKey);
    const downloadedBinaries = await checkAndDownloadBinaries(url, binaries, cachePath, platform, arch, checksums);
    await installBinaries(downloadedBinaries, BIN_DIR, cachePath);
    (0, utils_1.say)('done!');
}
exports.downloadAndInstallFoundryBinaries = downloadAndInstallFoundryBinaries;
//# sourceMappingURL=index.cjs.map