{"version":3,"file":"types.cjs","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":";;;AAuBA,mBAAmB;AAEnB,gBAAgB;AAEhB,IAAY,YAGX;AAHD,WAAY,YAAY;IACtB,+BAAe,CAAA;IACf,+BAAe,CAAA;AACjB,CAAC,EAHW,YAAY,4BAAZ,YAAY,QAGvB;AAED,IAAY,SAGX;AAHD,WAAY,SAAS;IACnB,wBAAW,CAAA;IACX,2BAAc,CAAA;AAChB,CAAC,EAHW,SAAS,yBAAT,SAAS,QAGpB;AAED,IAAY,QAIX;AAJD,WAAY,QAAQ;IAClB,6BAAiB,CAAA;IACjB,2BAAe,CAAA;IACf,0BAAc,CAAA;AAChB,CAAC,EAJW,QAAQ,wBAAR,QAAQ,QAInB;AAED,IAAY,MAKX;AALD,WAAY,MAAM;IAChB,yBAAe,CAAA;IACf,yBAAe,CAAA;IACf,uBAAa,CAAA;IACb,2BAAiB,CAAA;AACnB,CAAC,EALW,MAAM,sBAAN,MAAM,QAKjB;AAsDD,qBAAqB","sourcesContent":["import type { Agent as HttpAgent } from 'node:http';\nimport type { Agent as HttpsAgent } from 'node:https';\nimport type { InferredOptionTypes, Options } from 'yargs';\n\n// #region utils\n\ntype UnionToIntersection<U> = ((k: U) => void) extends (k: infer I) => void\n  ? I\n  : never;\n\ntype LastInUnion<U extends PropertyKey> =\n  UnionToIntersection<\n    U extends PropertyKey ? () => U : never\n  > extends () => infer Last\n    ? Last\n    : never;\n\ntype UnionToTuple<U extends PropertyKey, Last = LastInUnion<U>> = [U] extends [\n  never,\n]\n  ? []\n  : [...UnionToTuple<Exclude<U, Last>>, Last];\n\n// #endregion utils\n\n// #region enums\n\nexport enum Architecture {\n  Amd64 = 'amd64',\n  Arm64 = 'arm64',\n}\n\nexport enum Extension {\n  Zip = 'zip',\n  Tar = 'tar.gz',\n}\n\nexport enum Platform {\n  Windows = 'win32',\n  Linux = 'linux',\n  Mac = 'darwin',\n}\n\nexport enum Binary {\n  Anvil = 'anvil',\n  Forge = 'forge',\n  Cast = 'cast',\n  Chisel = 'chisel',\n}\n\n// #endregion enums\n\n// #region helpers\n\n/**\n * Tuple representing all members of the {@link Binary} enum.\n */\nexport type BinariesTuple = UnionToTuple<Binary>;\n\n/**\n * Tuple representing all members of the {@link Architecture} enum.\n */\nexport type ArchitecturesTuple = UnionToTuple<Architecture>;\n\n/**\n * Tuple representing all members of the {@link Platform} enum.\n */\nexport type PlatformsTuple = UnionToTuple<Platform>;\n\n/**\n * Checksum types expected by the CLI.\n */\nexport type Checksums = {\n  algorithm: string;\n  binaries: Record<Binary, Record<`${Platform}-${Architecture}`, string>>;\n};\n\n/**\n * Checksum type expected by application code, specific to the selected\n * {@link Platform} and {@link Architecture}.\n *\n * See also: {@link Checksums}.\n */\nexport type PlatformArchChecksums = {\n  algorithm: string;\n  binaries: Record<Binary, string>;\n};\n\n/**\n * Given a map of raw yargs options config, returns a map of inferred types.\n */\nexport type ParsedOptions<O extends { [key: string]: Options }> = {\n  [key in keyof O]: InferredOptionTypes<O>[key];\n};\n\nexport type DownloadOptions = {\n  method?: 'GET' | 'HEAD';\n  headers?: Record<string, string>;\n  agent?: HttpsAgent | HttpAgent;\n  maxRedirects?: number;\n};\n\n// #endregion helpers\n"]}