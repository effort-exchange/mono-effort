"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformChecksums = exports.isCodedError = exports.getVersion = exports.say = exports.normalizeSystemArchitecture = exports.noop = void 0;
const node_child_process_1 = require("node:child_process");
const node_os_1 = require("node:os");
const types_1 = require("./types.cjs");
/**
 * No Operation. A function that does nothing and returns nothing.
 *
 * @returns `undefined`
 */
const noop = () => undefined;
exports.noop = noop;
/**
 * Returns the system architecture, normalized to one of the supported
 * {@link Architecture} values.
 *
 * @param architecture - The architecture string to normalize (e.g., 'x64', 'arm64')
 * @returns The normalized architecture value
 */
function normalizeSystemArchitecture(architecture = (0, node_os_1.arch)()) {
    if (architecture.startsWith('arm')) {
        // if `arm*`, use `arm64`
        return types_1.Architecture.Arm64;
    }
    else if (architecture === 'x64') {
        // if `x64`, it _might_ be amd64 running via Rosetta on Apple Silicon
        // (arm64). we can check this by running `sysctl.proc_translated` and
        // checking the output; `1` === `arm64`. This can happen if the user is
        // running an amd64 version of Node on Apple Silicon. We want to use the
        // binaries native to the system for better performance.
        try {
            if ((0, node_child_process_1.execSync)('sysctl -n sysctl.proc_translated 2>/dev/null')[0] === 1) {
                return types_1.Architecture.Arm64;
            }
        }
        catch {
            // Ignore error: if sysctl check fails, we assume native amd64
        }
    }
    return types_1.Architecture.Amd64; // Default for all other architectures
}
exports.normalizeSystemArchitecture = normalizeSystemArchitecture;
/**
 * Log a message to the console.
 *
 * @param message - The message to log
 */
function say(message) {
    console.log(`[foundryup] ${message}`);
}
exports.say = say;
/**
 * Get the version of the binary at the given path.
 *
 * @param binPath - Path to the binary executable
 * @returns The `--version` reported by the binary
 * @throws If the binary fails to report its version
 */
function getVersion(binPath) {
    try {
        return (0, node_child_process_1.execFileSync)(binPath, ['--version']).subarray(0, -1); // ignore newline
    }
    catch (error) {
        const msg = `Failed to get version for ${binPath}

Your selected platform or architecture may be incorrect, or the binary may not
support your system. If you believe this is an error, please report it.`;
        if (error instanceof Error) {
            error.message = `${msg}\n\n${error.message}`;
            throw error;
        }
        throw new AggregateError([new Error(msg), error]);
    }
}
exports.getVersion = getVersion;
/**
 * Type guard to check if an error has a code property.
 *
 * @param error - The error to check
 * @returns True if the error has a code property
 */
function isCodedError(error) {
    return (error instanceof Error && 'code' in error && typeof error.code === 'string');
}
exports.isCodedError = isCodedError;
/**
 * Transforms the CLI checksum object into a platform+arch-specific checksum
 * object.
 *
 * @param checksums - The CLI checksum object
 * @param targetPlatform - The build platform
 * @param targetArch - The build architecture
 * @returns Platform and architecture specific checksums or null if no checksums provided
 */
function transformChecksums(checksums, targetPlatform, targetArch) {
    if (!checksums) {
        return null;
    }
    const key = `${targetPlatform}-${targetArch}`;
    return {
        algorithm: checksums.algorithm,
        binaries: Object.entries(checksums.binaries).reduce((acc, [name, record]) => {
            acc[name] = record[key];
            return acc;
        }, {}),
    };
}
exports.transformChecksums = transformChecksums;
//# sourceMappingURL=utils.cjs.map