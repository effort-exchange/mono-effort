/// <reference types="node" />
/// <reference types="node" />
import type { Agent as HttpAgent } from "node:http";
import type { Agent as HttpsAgent } from "node:https";
import type { InferredOptionTypes, Options } from "yargs";
type UnionToIntersection<U> = ((k: U) => void) extends (k: infer I) => void ? I : never;
type LastInUnion<U extends PropertyKey> = UnionToIntersection<U extends PropertyKey ? () => U : never> extends () => infer Last ? Last : never;
type UnionToTuple<U extends PropertyKey, Last = LastInUnion<U>> = [U] extends [
    never
] ? [] : [...UnionToTuple<Exclude<U, Last>>, Last];
export declare enum Architecture {
    Amd64 = "amd64",
    Arm64 = "arm64"
}
export declare enum Extension {
    Zip = "zip",
    Tar = "tar.gz"
}
export declare enum Platform {
    Windows = "win32",
    Linux = "linux",
    Mac = "darwin"
}
export declare enum Binary {
    Anvil = "anvil",
    Forge = "forge",
    Cast = "cast",
    Chisel = "chisel"
}
/**
 * Tuple representing all members of the {@link Binary} enum.
 */
export type BinariesTuple = UnionToTuple<Binary>;
/**
 * Tuple representing all members of the {@link Architecture} enum.
 */
export type ArchitecturesTuple = UnionToTuple<Architecture>;
/**
 * Tuple representing all members of the {@link Platform} enum.
 */
export type PlatformsTuple = UnionToTuple<Platform>;
/**
 * Checksum types expected by the CLI.
 */
export type Checksums = {
    algorithm: string;
    binaries: Record<Binary, Record<`${Platform}-${Architecture}`, string>>;
};
/**
 * Checksum type expected by application code, specific to the selected
 * {@link Platform} and {@link Architecture}.
 *
 * See also: {@link Checksums}.
 */
export type PlatformArchChecksums = {
    algorithm: string;
    binaries: Record<Binary, string>;
};
/**
 * Given a map of raw yargs options config, returns a map of inferred types.
 */
export type ParsedOptions<O extends {
    [key: string]: Options;
}> = {
    [key in keyof O]: InferredOptionTypes<O>[key];
};
export type DownloadOptions = {
    method?: 'GET' | 'HEAD';
    headers?: Record<string, string>;
    agent?: HttpsAgent | HttpAgent;
    maxRedirects?: number;
};
export {};
//# sourceMappingURL=types.d.mts.map