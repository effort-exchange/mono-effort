"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.startDownload = void 0;
const node_http_1 = require("node:http");
const node_https_1 = require("node:https");
const node_stream_1 = require("node:stream");
const promises_1 = require("node:stream/promises");
/**
 * A PassThrough stream that emits a 'response' event when the HTTP(S) response is available.
 */
class DownloadStream extends node_stream_1.Stream.PassThrough {
    /**
     * Returns a promise that resolves with the HTTP(S) IncomingMessage response.
     *
     * @returns The HTTP(S) response stream.
     */
    async response() {
        return new Promise((resolve, reject) => {
            this.once('response', resolve);
            this.once('error', reject);
        });
    }
}
/**
 * Starts a download from the given URL.
 *
 * @param url - The URL to download from
 * @param options - The download options
 * @param redirects - The number of redirects that have occurred
 * @returns A stream of the download
 */
function startDownload(url, options = {}, redirects = 0) {
    const MAX_REDIRECTS = options.maxRedirects ?? 5;
    const request = url.protocol === 'http:' ? node_http_1.request : node_https_1.request;
    const stream = new DownloadStream();
    request(url, options, (response) => {
        stream.once('close', () => {
            response.destroy();
        });
        const { statusCode, statusMessage, headers } = response;
        // handle redirects
        if (statusCode &&
            statusCode >= 300 &&
            statusCode < 400 &&
            headers.location) {
            if (redirects >= MAX_REDIRECTS) {
                stream.emit('error', new Error('Too many redirects'));
                response.destroy();
            }
            else {
                // note: we don't emit a response until we're done redirecting, because
                // handlers only expect it to be emitted once.
                (0, promises_1.pipeline)(startDownload(new URL(headers.location, url), options, redirects + 1)
                    // emit the response event to the stream
                    .once('response', stream.emit.bind(stream, 'response')), stream).catch(stream.emit.bind(stream, 'error'));
                response.destroy();
            }
        }
        // check for HTTP errors
        else if (!statusCode || statusCode < 200 || statusCode >= 300) {
            stream.emit('error', new Error(`Request to ${url} failed. Status Code: ${statusCode} - ${statusMessage}`));
            response.destroy();
        }
        else {
            // resolve with response stream
            stream.emit('response', response);
            response.once('error', stream.emit.bind(stream, 'error'));
            (0, promises_1.pipeline)(response, stream).catch(stream.emit.bind(stream, 'error'));
        }
    })
        .once('error', stream.emit.bind(stream, 'error'))
        .end();
    return stream;
}
exports.startDownload = startDownload;
//# sourceMappingURL=download.cjs.map